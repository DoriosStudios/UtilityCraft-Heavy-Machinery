import { Multiblock, Generator, Energy, FluidManager } from '../DoriosMachinery/main.js'
import { ModalFormData } from '@minecraft/server-ui'
import { ItemStack } from '@minecraft/server'

// #region Config
/**
 * Thermo Reactor configuration.
 *
 * Conventions:
 * - Simulation runs per game tick.
 * - mB = milliBuckets (volume), PSI = pressure, K = kelvin (temperature).
 * - Units are documented in JSDoc rather than in property names.
 *
 * @typedef {Object} ThermoReactorConfig
 *
 * @property {number} baseLavaBurnRate  Base lava consumption per tick when Speed=1. Units: mB/tick.
 * @property {number} maxCoreTemperatureK  Maximum supported core temperature before meltdown. Units: K.
 * @property {number} maxPressurePSI  Maximum supported pressure before explosion. Units: PSI.
 *
 * @property {number} ventReleaseRate  Steam/pressure vented by a single vent block per tick. Units: mB/tick.
 * @property {number} conductorHeatDissipation  Heat dissipated by a single heat conductor per tick. Units: K/tick.
 *
 * @property {number} waterPerKelvin  Water required to dissipate 1 K of heat. Units: mB/K.
 * @property {number} pressurePerSteam  Pressure generated by steam. Units: PSI/mB.
 * @property {number} heatPerLavaUnit  Heat generated by burning 1 mB of lava. Units: K/mB.
 * @property {number} energyPerLavaUnit  Energy generated from burning 1 mB of lava. Units: DE/mB.
 *
 * @property {number} waterCapacityPerEmptyBlock  Water storage capacity added per empty block. Units: mB.
 * @property {number} steamCapacityPerEmptyBlock  Steam storage capacity added per empty block. Units: mB.
 * @property {number} lavaCapacityPerFluidCell  Lava storage capacity per fluid cell. Units: mB.
 * 
 * @property {Object} initialReactorData  Initial values for each stat.
 */

/** @type ThermoReactorConfig */
const config = {
    // Settings / Limits
    maxCoreTemperatureK: 1200,       // K
    maxPressurePSI: 300,            // PSI

    // Component rates
    ventReleaseRate: 40,             // mB/tick per vent block
    conductorHeatDissipation: 0.05,     // K/tick per conductor block

    // Conversion factors
    waterPerKelvin: 500,              // mB/K
    pressurePerSteam: 0.0001,            // PSI/mB
    heatPerLavaUnit: 0.008,              // K/mB
    energyPerLavaUnit: 2000,          // DE/mB

    // Capacities
    waterCapacityPerEmptyBlock: 256_000, // mB
    steamCapacityPerEmptyBlock: 256_000, // mB
    lavaCapacityPerFluidCell: 256_000,   // mB

    initialReactorData: {
        state: 'off',
        rate: 100,
        pressure: 0,
        temperature: 300,
        efficiency: 0.1,
        time: 0,
        warning: ''
    }
}


/**
 * Core temperature constants.
 * - CORE_TMIN_K: logic floor (K)
 * - CORE_TCAP_K: absolute cap (K) — cannot exceed
 * - CORE_TIDEAL_FRAC: ideal temp as fraction of supported span (0..1)
 * - WARN_*: UI thresholds
 */
const CORE_TMIN_K = 300;
const CORE_TCAP_K = 1273.15;
const CORE_TIDEAL_FRAC = 0.5;
const WARN_OVERHEAT_K = 1000;
const WARN_DANGER_K = 1200;

/**
 * Efficiency shaping (temperature-only).
 * EFF_MIN..MAX ∈ [0,1]; GAMMA/ALPHA tune bowl sharpness and asymmetry.
 */
const EFF_MIN = 0.10;
const EFF_MAX = 0.80;
const EFF_GAMMA = 5.0;
const EFF_ALPHA_COLD = 1.6;
const EFF_ALPHA_HOT = 1.2;

// #endregion

DoriosAPI.register.blockComponent('thermo_reactor', {
    async onPlayerInteract(e, { params: settings }) {
        const { block, player } = e;
        const dim = block.dimension;

        let { x, y, z } = block.center(); y -= 0.25;

        const main = player.getEquipment('Mainhand');
        const isWrench = main?.typeId.includes("wrench");

        let entity = dim.getEntitiesAtBlockLocation(block.location)[0];

        if (!isWrench && entity) {
            if (!FluidManager.handleFluidItemInteraction(player, entity, main)) {
                showBurnRateConfigForm(entity, player);
                return
            }
            return;
        }

        if (!entity) {
            entity = dim.spawnEntity("utilitycraft:thermo_reactor", { x, y, z });
            entity.nameTag = `entity.utilitycraft:${settings.entity.name}.name`;
            Energy.initialize(entity)
        }

        Multiblock.deactivateMultiblock(player, entity);
        Multiblock.emptyBlocks(entity, "minecraft:water");

        const structure = await Multiblock.detectFromController(e, settings.required_case);
        if (!structure) return;

        const { components, bounds } = structure;


        if (!components["thermo_core"]) {
            player.sendMessage("§c[Reactor] Missing Thermo Core — reactor cannot operate.");
            return;
        }

        const energyCap = Multiblock.activateMultiblock(entity, structure);
        if (energyCap <= 0) {
            player.sendMessage("§c[Reactor] At least 1 energy unit is required.");
            Multiblock.deactivateMultiblock(player, entity)
            return
        }

        Multiblock.fillEmptyBlocks(bounds, dim, "minecraft:water");

        entity.setDynamicProperty(
            "dorios:rateSpeed",
            energyCap / settings.multiblock.transfer_rate_ratio
        );

        const lavaCapacity =
            (components["fluid_cell"] ?? 0) * config.lavaCapacityPerFluidCell;

        const internalVolume = (components["air"] ?? 0);

        const waterCapacity = internalVolume * config.waterCapacityPerEmptyBlock;
        const steamCapacity = internalVolume * config.steamCapacityPerEmptyBlock;

        const heatDissipation =
            (components["heat_conductor"] ?? 0) * config.conductorHeatDissipation;

        const ventRate =
            (components["vent"] ?? 0) * config.ventReleaseRate;

        if (lavaCapacity <= 0) player.sendMessage("§e[Warning] No Lava Cells detected.");
        if (waterCapacity <= 0) player.sendMessage("§e[Warning] No volume for water cooling.");
        if (steamCapacity <= 0) player.sendMessage("§e[Warning] No internal steam volume.");
        if (heatDissipation <= 0) player.sendMessage("§e[Warning] No Heat Conductors found.");
        if (ventRate <= 0) player.sendMessage("§e[Warning] No vents detected — pressure cannot be released.");

        const reactorStats = {
            lavaCapacity,
            waterCapacity,
            steamCapacity,
            heatDissipation,
            ventRate,
            energyCap,
            bounds
        };

        entity.setDynamicProperty("reactorStats", JSON.stringify(reactorStats));

        const fluids = FluidManager.initializeMultiple(entity, 2);
        fluids[0].setCap(1000)
        fluids[1].setCap(1000)

        player.sendMessage("§a[Reactor] Thermo Reactor structure validated.");
        player.sendMessage(`§7Energy Capacity: §b${Energy.formatEnergyToText(energyCap)}`);
        player.sendMessage(`§7Lava Capacity: §b${FluidManager.formatFluid(lavaCapacity)}`);
        player.sendMessage(`§7Water Capacity: §b${FluidManager.formatFluid(waterCapacity)}`);
        player.sendMessage(`§7Steam Capacity: §b${FluidManager.formatFluid(steamCapacity)}`);
        player.sendMessage(`§7Heat Dissipation: §b${heatDissipation.toFixed(2)} K°/t`);
        player.sendMessage(`§7Steam Venting: §b${FluidManager.formatFluid(ventRate)}/t`);
        player.sendMessage(`§7Max Pressure: §b${config.maxPressurePSI} PSI`);
        player.sendMessage(`§7Max Heat: §b${config.maxCoreTemperatureK} K°`);
    },
    onPlayerBreak({ block, player }) {
        const entity = block.dimension.getEntitiesAtBlockLocation(block.location)[0]
        if (!entity) return
        Multiblock.deactivateMultiblock(player, entity)
        Multiblock.emptyBlocks(entity, 'minecraft:water')
        entity.remove()
    },
    onTick({ block }, { params: settings }) {
        if (!worldLoaded) return;
        const reactor = new Generator(block, settings);
        if (!reactor.valid) return;

        const newRate = reactor.entity.getDynamicProperty("dorios:rateSpeed");
        reactor.setRate(newRate);

        const { entity, energy } = reactor
        energy.transferToNetwork(reactor.rate);
        const data = getReactorInfo(entity);

        const fluids = FluidManager.initializeMultiple(entity, 2);
        fluids.forEach(fluid => fluid.display(fluid.index + 2))

        const lava =
            fluids[0]?.type === "lava" ? fluids[0] :
                fluids[1]?.type === "lava" ? fluids[1] : null;
        const fuel = lava ? lava.get() : 0;
        if (lava) lava.setCap(data.lavaCapacity)

        const water =
            fluids[0]?.type === "water" ? fluids[0] :
                fluids[1]?.type === "water" ? fluids[1] : null;
        const coolant = water ? water.get() : 0;
        if (water) water.setCap(data.waterCapacity)

        const f = tickSpeed;
        let working = false;

        const tMin = CORE_TMIN_K;
        const tMax = CORE_TCAP_K;
        const tSpan = Math.max(1, tMax - tMin);

        data.temperature = Math.max(tMin, data.temperature ?? tMin);

        const tNorm = Math.min(1, Math.max(0, (data.temperature - tMin) / tSpan));
        const tIdeal = CORE_TIDEAL_FRAC;
        const tDist = Math.abs(tNorm - tIdeal) / tIdeal;

        const baseShape = Math.max(0, 1 - Math.pow(tDist, EFF_GAMMA));
        const shape = tNorm < tIdeal
            ? Math.pow(baseShape, EFF_ALPHA_COLD)
            : Math.pow(baseShape, EFF_ALPHA_HOT);

        data.efficiency = EFF_MIN + (EFF_MAX - EFF_MIN) * shape;

        if (fuel > 0 && data.state !== "off") {
            const rate = Math.min(fuel, data.rate * f);
            if (rate > 0) {
                lava.consume(rate)
                fireLoop(entity, f);
                const waste = 1 - data.efficiency;

                // Energía producida sigue ligada a la eficiencia
                const energyProduced = rate * config.energyPerLavaUnit * data.efficiency;

                // Calor bruto generado por el combustible + “waste heat”
                const rawHeat = rate * config.heatPerLavaUnit * (1 + waste);

                // Rango de temperatura donde trabajamos “realmente”
                const tMin = CORE_TMIN_K;
                const tMax = CORE_TCAP_K; // 1200 K
                const span = Math.max(1e-6, tMax - tMin);

                // Normalizamos temperatura a [0, 1]
                const normT = Math.min(1, Math.max(0, (data.temperature - tMin) / span));

                // Curva de desaceleración: 1 al estar frío, 0 al llegar a tMax
                // exponencial suavizada (tipo “logarítmica” en efecto)
                const TEMP_SLOWDOWN_EXP = 2; // puedes subir a 2.0 si quieres más agresivo
                const slowdown = 1 - Math.pow(normT, TEMP_SLOWDOWN_EXP);

                // Aseguramos que NUNCA se caliente más rápido al subir la T
                let heatProduced = rawHeat * slowdown;

                // Aplicamos energía y calor
                energy.add(energyProduced);
                data.producing = energyProduced / f;
                data.temperature += heatProduced;
                data.time += f;
                working = true;
                data.warning = undefined;

            }

        } else {
            if (data.state !== "off") data.warning = "§eMissing Fuel!";
            data.time = 0;
            data.producing = 0;
        }

        if (coolant > 0 && water) {
            const maxByDiss = (data.heatDissipation ?? 0) * f;
            const maxByWater = coolant / (config.waterPerKelvin ?? 1);
            const maxByTMin = Math.max(0, data.temperature - tMin);

            const heatDissipated = Math.min(maxByDiss, maxByWater, maxByTMin);
            if (heatDissipated > 0) {
                spawnRandomVentSmoke(entity);
                const waterConsumed = heatDissipated * (config.waterPerKelvin ?? 0);
                water.consume(waterConsumed);
                data.temperature -= heatDissipated;
            }
        } else {
            if (working) data.warning = "§cMissing Coolant!";
        }

        data.temperature = Math.min(CORE_TCAP_K, Math.max(CORE_TMIN_K, data.temperature));

        if (data.temperature >= WARN_DANGER_K) {
            data.warning = "§cCore overheating!";
        } else if (data.temperature >= WARN_OVERHEAT_K) {
            data.warning ??= "§6Overheating!";
        }

        if (working && (water?.get?.() ?? 0) > 0 && (data.warning ?? "") === "") {
            data.warning = "§2Active";
        }

        if (data.state === "off") data.warning = "§eStopped";

        updateReactorInfoItem(data, reactor);
        reactor.displayEnergy();
    }
})

/**
 * Updates the reactor status label and temperature bar.
 *
 * @param {Object} data 
 * @param {Generator} reactor 
 */
function updateReactorInfoItem(data, reactor) {

    // ----- LABEL -----
    reactor.setLabel(`
§r§3Producing: §f${Energy.formatEnergyToText(data.producing ?? 0)}/t
§r§3Burn Rate: §f${(data.rate ?? 0).toFixed(2)} mB/t
§r§3Temperature: §f${(data.temperature ?? 0).toFixed(2)} K
§r§3Efficiency: §f${((data.efficiency ?? 0) * 100).toFixed(2)}%%
§r${data.warning ?? ""}
    `);

    // ----- TEMPERATURE BAR -----
    const inv = reactor.inv;
    if (inv) {
        const temp = data.temperature ?? CORE_TMIN_K;
        const segment = Math.floor(
            (temp - CORE_TMIN_K) / (CORE_TCAP_K - CORE_TMIN_K) * 31
        );

        let name = "utilitycraft:temperature_";
        if (segment < 10) name += "0";
        name += segment;

        const bar = new ItemStack(name);
        bar.nameTag = `§r§f${temp.toFixed(2)} K`;

        inv.setItem(4, bar);
    }

    reactor.entity.setDynamicProperty("reactorData", JSON.stringify(data));
}



/**
 * Reactor state and statistics object.
 * 
 * @typedef {Object} ReactorInfo
 * @property {number} rate Reactor base processing rate (mB/t).
 * @property {number} pressure Current pressure of the reactor (PSI).
 * @property {number} temperature Current temperature of the reactor (K).
 * @property {number} efficiency Reactor efficiency percentage (0–100).
 * @property {number} time Elapsed time in seconds.
 * @property {string} warning Warning message if reactor is unstable, empty otherwise.
 * 
 * @property {number} lavaCapacity Maximum lava capacity (mB).
 * @property {number} waterCapacity Maximum water capacity (mB).
 * @property {number} steamCapacity Maximum steam capacity (mB).
 * @property {number} heatDissipation Heat dissipated per tick (K/t).
 * @property {number} ventRate Steam vented per tick (mB/t).
 * @property {number} energyCap Maximum internal energy capacity (DE).
 */

/**
 * Get full reactor info (data + stats) from entity.
 *
 * @param {any} entity Target entity with dynamic properties.
 * @returns {ReactorInfo}
 */
function getReactorInfo(entity) {
    try {
        const rawData = entity.getDynamicProperty('reactorData');
        const data = rawData ? JSON.parse(rawData) : config.initialReactorData;

        const rawStats = entity.getDynamicProperty('reactorStats')
        const stats = rawStats ? JSON.parse(rawStats) : {
            lavaCapacity: 0,
            waterCapacity: 0,
            steamCapacity: 0,
            heatDissipation: 0,
            ventRate: 0,
            energyCap: 0
        };

        return { ...data, ...stats };
    } catch {
        return { ...config.initialReactorData, lavaCapacity: 0, waterCapacity: 0, steamCapacity: 0, heatDissipation: 0, ventRate: 0, energyCap: 0 };
    }
}


/**
 * Show a modal to configure reactor burn rate and on/off state.
 * Reads current values from the entity (data.rate, data.state) and writes them back.
 * @param {Entity} entity - Reactor entity that holds the data.
 * @param {Player} player - Player to show the form to.
 */
async function showBurnRateConfigForm(entity, player) {
    // Read current reactor data
    const data = (typeof getReactorInfo === "function" ? getReactorInfo(entity) : {}) || {};
    const currentRate = Number(data.rate) || 0.1;
    const currentEnabled =
        typeof data.state === "string" ? data.state.toLowerCase() !== "off" : !!data.state;

    // Build form
    const form = new ModalFormData()
        .title("Reactor Burn Rate")
        .textField(
            `Burn rate (mB/t)\nFaster burn = more power & heat.\nSet a rate your cooling can sustain. e.g. 10`,
            `Set a burn rate: 100`,
            { defaultValue: `${currentRate}` }
        )
        .toggle("Enabled (on/off)", { defaultValue: currentEnabled });

    // Show and handle response
    const res = await form.show(player);
    if (res.canceled) return;

    const [rateInput, enabledToggle] = res.formValues;

    // Parse and validate
    let parsed = parseFloat(String(rateInput).replace(",", "."));
    if (!Number.isFinite(parsed) || parsed <= 0) {
        parsed = 0
    }

    // Write back
    data.rate = parsed;
    data.state = enabledToggle ? "on" : "off";

    if (typeof setReactorInfo === "function") {
        setReactorInfo(entity, data);
    } else if (typeof updateReactorInfo === "function") {
        updateReactorInfo(entity, data);
    } else if (entity.setDynamicProperty) {
        // Fallback if you store data as a dynamic property
        entity.setDynamicProperty("reactorData", JSON.stringify(data));
    }
}

/**
 * Spawns "campfire_tall_smoke_particle" on ~50% of vent blocks, chosen at random.
 * 8 -> 4, 7 -> 3, etc.
 * @param {import('@minecraft/server').Entity} entity
 * @param {number} [ratio=0.5] Fraction of vents to use (0..1)
 * @param {boolean} [center=true] If true, spawns at block centers (+0.5)
 */
function spawnRandomVentSmoke(entity, ratio = 0.1, center = true) {
    const dim = entity.dimension;

    let vents = [];
    const raw = entity.getDynamicProperty('ventBlocks');
    try { vents = raw ? JSON.parse(raw) : []; } catch { vents = []; }

    const n = vents.length;
    if (n < 2) return;

    const k = Math.max(1, Math.floor(n * ratio)); // 8->4
    // Partial Fisher–Yates to sample k unique vents without replacement
    for (let i = n - 1; i > n - 1 - k; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [vents[i], vents[j]] = [vents[j], vents[i]];
    }

    // Spawn particle on the sampled vents
    for (let i = n - k; i < n; i++) {
        const v = vents[i];
        const pos = center ? { x: v.x + 0.5, y: v.y + 0.5, z: v.z + 0.5 } : v;
        try {
            dim.spawnParticle("minecraft:campfire_tall_smoke_particle", pos);
        } catch { }
    }
}

const PERIOD = 30; // 2 s

function fireLoop(e, f) {
    let t = (Number(e.getDynamicProperty('fs_t')) || 0) + f;
    if (t >= PERIOD) { e.dimension.playSound('block.campfire.crackle', e.location); t %= PERIOD; }
    e.setDynamicProperty('fs_t', t);
}

