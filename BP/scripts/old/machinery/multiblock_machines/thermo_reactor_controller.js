import * as doriosAPI from '../../doriosAPI.js'
import { MultiblockStructure } from '../multiblock_creator.js'
import { EnergyManager, LiquidManager, Machinery, formatEnergyToText, formatLiquid } from '../managers.js'
import { Entity, Player, ItemStack, system, world } from '@minecraft/server'
import { ModalFormData } from '@minecraft/server-ui'

// #region Config
/**
 * Thermo Reactor configuration.
 *
 * Conventions:
 * - Simulation runs per game tick.
 * - mB = milliBuckets (volume), PSI = pressure, K = kelvin (temperature).
 * - Units are documented in JSDoc rather than in property names.
 *
 * @typedef {Object} ThermoReactorConfig
 *
 * @property {number} baseLavaBurnRate  Base lava consumption per tick when Speed=1. Units: mB/tick.
 * @property {number} maxCoreTemperatureK  Maximum supported core temperature before meltdown. Units: K.
 * @property {number} maxPressurePSI  Maximum supported pressure before explosion. Units: PSI.
 *
 * @property {number} ventReleaseRate  Steam/pressure vented by a single vent block per tick. Units: mB/tick.
 * @property {number} conductorHeatDissipation  Heat dissipated by a single heat conductor per tick. Units: K/tick.
 *
 * @property {number} waterPerKelvin  Water required to dissipate 1 K of heat. Units: mB/K.
 * @property {number} pressurePerSteam  Pressure generated by steam. Units: PSI/mB.
 * @property {number} heatPerLavaUnit  Heat generated by burning 1 mB of lava. Units: K/mB.
 * @property {number} energyPerLavaUnit  Energy generated from burning 1 mB of lava. Units: DE/mB.
 *
 * @property {number} waterCapacityPerEmptyBlock  Water storage capacity added per empty block. Units: mB.
 * @property {number} steamCapacityPerEmptyBlock  Steam storage capacity added per empty block. Units: mB.
 * @property {number} lavaCapacityPerFluidCell  Lava storage capacity per fluid cell. Units: mB.
 * 
 * @property {Object} initialReactorData  Initial values for each stat.
 */

/** @type ThermoReactorConfig */
const config = {
    // Settings / Limits
    maxCoreTemperatureK: 1200,       // K
    maxPressurePSI: 300,            // PSI

    // Component rates
    ventReleaseRate: 40,             // mB/tick per vent block
    conductorHeatDissipation: 0.05,     // K/tick per conductor block

    // Conversion factors
    waterPerKelvin: 500,              // mB/K
    pressurePerSteam: 0.0001,            // PSI/mB
    heatPerLavaUnit: 0.008,              // K/mB
    energyPerLavaUnit: 400,          // DE/mB

    // Capacities
    waterCapacityPerEmptyBlock: 256_000, // mB
    steamCapacityPerEmptyBlock: 256_000, // mB
    lavaCapacityPerFluidCell: 256_000,   // mB

    initialReactorData: {
        state: 'off',
        rate: 100,
        pressure: 0,
        temperature: 300,
        efficiency: 0.1,
        time: 0,
        warning: ''
    }
}


/**
 * Core temperature constants.
 * - CORE_TMIN_K: logic floor (K)
 * - CORE_TCAP_K: absolute cap (K) — cannot exceed
 * - CORE_TIDEAL_FRAC: ideal temp as fraction of supported span (0..1)
 * - WARN_*: UI thresholds
 */
const CORE_TMIN_K = 300;
const CORE_TCAP_K = 1273.15;
const CORE_TIDEAL_FRAC = 0.5;
const WARN_OVERHEAT_K = 1000;
const WARN_DANGER_K = 1200;

/**
 * Efficiency shaping (temperature-only).
 * EFF_MIN..MAX ∈ [0,1]; GAMMA/ALPHA tune bowl sharpness and asymmetry.
 */
const EFF_MIN = 0.10;
const EFF_MAX = 0.80;
const EFF_GAMMA = 5.0;
const EFF_ALPHA_COLD = 1.6;
const EFF_ALPHA_HOT = 1.2;

const LOG_ALPHA = 8.0;   // curvature (higher => stronger slowdown near cap)
const MAX_REDUCT = 0.90;  // up to 90% heating reduction at cap
const MIN_FACTOR = 0.06;  // never drop below 6% of base heating

// #endregion

system.beforeEvents.startup.subscribe(e => {
    e.blockComponentRegistry.registerCustomComponent('utilitycraft:thermo_reactor', {
        onTick({ block }) {
            const gen = new Machinery(block, {
                nameTag: 'entity.utilitycraft:thermo_reactor.name',
                liquidTypes: 2
            })
            if (!gen.entity) return
            const trueRateSpeed = gen.entity.getDynamicProperty('dorios:rateSpeed')
            const rateSpeed = trueRateSpeed * gen.refreshSpeed
            if (rateSpeed <= 0) return

            // Info
            const [water, lava] = ['water', 'lava'].map(t => gen.liquid.find(l => l.type === t));
            const { energy, entity } = gen
            const f = gen.refreshSpeed

            const info = getReactorInfo(entity);
            if (water) water.setCap(info.waterCapacity)
            if (lava) lava.setCap(info.lavaCapacity)
            Machinery.tick(() => {
                // --- Energy + UI updates ---
                energy.transferToNetwork(rateSpeed);
                gen.displayEnergy(trueRateSpeed);
                gen.liquid[0]?.display?.(3);
                gen.liquid[1]?.display?.(6);

                const data = getReactorInfo(entity);

                const fuel = lava?.get?.() ?? 0;
                const coolant = water?.get?.() ?? 0;

                let working = false;

                // --- Temperature bounds & normalization ---
                const tMin = CORE_TMIN_K;
                const tMax = config.maxCoreTemperatureK;              // supported max (e.g., 1200 K)
                const tSpan = Math.max(1, tMax - tMin);
                data.temperature = Math.max(tMin, data.temperature ?? tMin);

                // Normalize to supported range for efficiency shaping
                const tNorm = Math.min(1, Math.max(0, (data.temperature - tMin) / tSpan));
                const tIdeal = CORE_TIDEAL_FRAC;
                const tDist = Math.abs(tNorm - tIdeal) / tIdeal; // 0=ideal, 1=extreme

                // --- Efficiency (unchanged: temperature-only, asymmetric bowl) ---
                const baseShape = Math.max(0, 1 - Math.pow(tDist, EFF_GAMMA));
                const shape =
                    tNorm < tIdeal
                        ? Math.pow(baseShape, EFF_ALPHA_COLD)
                        : Math.pow(baseShape, EFF_ALPHA_HOT);

                data.efficiency = EFF_MIN + (EFF_MAX - EFF_MIN) * shape; // ∈ [0.10 .. 0.95]

                // --- Fuel combustion ---
                if (fuel > 0 && data.state != 'off') {
                    const rate = Math.min(fuel, data.rate * f);
                    if (rate > 0) {
                        lava.add(-rate);
                        fireLoop(entity, f);

                        // Energy vs heat split by efficiency
                        const waste = 1 - data.efficiency;
                        const energyProduced = rate * config.energyPerLavaUnit * data.efficiency;
                        let heatProduced = rate * config.heatPerLavaUnit * (1 + waste);

                        // === Monotonic logarithmic damping: hotter -> slower heating ===
                        // Uses absolute cap span [tMin .. CORE_TCAP_K]; at tMin ~ no damping, near cap -> strong damping.
                        const capSpan = Math.max(1e-6, CORE_TCAP_K - tMin);
                        const tNormCap = Math.min(1, Math.max(0, (data.temperature - tMin) / capSpan)); // 0..1
                        const logFrac = Math.log1p(LOG_ALPHA * tNormCap) / Math.log1p(LOG_ALPHA); // 0..1
                        const heatDamp = Math.max(MIN_FACTOR, 1 - MAX_REDUCT * logFrac);           // 1 -> MIN_FACTOR

                        heatProduced *= heatDamp;

                        // Apply results
                        energy.add(energyProduced);
                        data.producing = energyProduced / f;
                        data.temperature += heatProduced;

                        data.time += f;
                        working = true;
                        data.warning = undefined;
                    }
                } else {
                    if (data.state != 'off') data.warning = '§eMissing Fuel!';
                    data.time = 0;
                    data.producing = 0;
                }

                // --- Heat dissipation / steam generation (always attempted) ---
                if (coolant > 0 && water) {
                    const maxByDiss = (data.heatDissipation ?? 0) * f;         // K
                    const maxByWater = coolant / (config.waterPerKelvin ?? 1);   // K
                    const maxByTMin = Math.max(0, data.temperature - tMin);

                    const heatDissipated = Math.min(maxByDiss, maxByWater, maxByTMin);

                    if (heatDissipated > 0) {
                        spawnRandomVentSmoke(entity);
                        const waterConsumed = heatDissipated * (config.waterPerKelvin ?? 0); // mB consumed
                        water.add(-waterConsumed);
                        data.temperature -= heatDissipated;
                    }
                } else {
                    if (working) data.warning = '§cMissing Coolant!';
                }

                // --- Final clamps & warnings (temperature-only) ---
                data.temperature = Math.min(CORE_TCAP_K, Math.max(CORE_TMIN_K, data.temperature));

                if (data.temperature >= WARN_DANGER_K) {
                    data.warning = '§cCore overheating!';
                } else if (data.temperature >= WARN_OVERHEAT_K) {
                    data.warning ??= '§6Overheating!';
                }

                // --- Status message (only if no warnings) ---
                if (working && (water?.get?.() ?? 0) > 0 && (data.warning ?? '') === '') {
                    data.warning = '§2Active';
                }
                if (data.state == 'off') data.warning = '§eStopped';

                updateReactorInfoItem(data, gen);
            });


        },
        async onPlayerBreak({ block, player }) {
            const entity = block.dimension.getEntitiesAtBlockLocation(block.location)[0]
            if (!entity) return
            MultiblockStructure.deactivateMultiblock(player, entity)
            MultiblockStructure.emptyBlocks(entity, 'minecraft:water')
            entity.remove()
        },
        async onPlayerInteract(e) {
            const { block, player } = e
            let { x, y, z } = block.location;

            const mainhand = doriosAPI.entities.getEquipment(player, 'Mainhand')
            const mainId = mainhand?.typeId
            let entity = block.dimension.getEntitiesAtBlockLocation(block.location)[0]

            if (mainId != 'twm:wrench' && entity) {
                showBurnRateConfigForm(entity, player)
                return
            }

            if (!entity) {
                y += 0.25; x += 0.5; z += 0.5;
                entity = block.dimension.spawnEntity('utilitycraft:thermo_reactor', { x, y, z })
                entity.nameTag = 'entity.utilitycraft:thermo_reactor.name'
                entity.runCommand(`scoreboard players set @s energy ${0}`)
            }
            MultiblockStructure.deactivateMultiblock(player, entity)
            MultiblockStructure.emptyBlocks(entity, 'minecraft:water')

            const structure = await MultiblockStructure.detectFromController(e, "dorios:multiblock_case")
            if (!structure) return

            const energyCap = MultiblockStructure.calculateEnergyCapacity(structure.components)
            if (energyCap <= 0) {
                player.sendMessage("§c[Matrix] At least 1 energy container its required to operate.");
                return
            }

            MultiblockStructure.activateMultiblock(entity, structure.inputBlocks)
            MultiblockStructure.fillEmptyBlocks(structure.bounds, entity.dimension, "minecraft:water")
            EnergyManager.setCap(entity, energyCap)
            entity.setDynamicProperty('dorios:caseBlocks', JSON.stringify(structure.caseBlocks))
            entity.setDynamicProperty('ventBlocks', JSON.stringify(structure.ventBlocks))
            entity.setDynamicProperty('dorios:rateSpeed', energyCap / 1000)

            const { components, bounds } = structure;

            if (!components['thermo_core']) {
                player.sendMessage("§c[Reactor] Thermo Core missing. This structure cannot operate as a reactor.");
                return;
            }

            const lavaCapacity = (components['fluid_cell'] ?? 0) * config.lavaCapacityPerFluidCell;
            const waterCapacity = (components['air'] ?? 0) * config.waterCapacityPerEmptyBlock;
            const steamCapacity = (components['air'] ?? 0) * config.steamCapacityPerEmptyBlock;
            const heatDissipation = (components['heat_conductor'] ?? 0) * config.conductorHeatDissipation;
            const ventRate = (components['vent'] ?? 0) * config.ventReleaseRate;

            if (lavaCapacity <= 0) {
                player.sendMessage("§e[Warning] No Lava Cells detected. The reactor has no access to heat.");
            }
            if (waterCapacity <= 0) {
                player.sendMessage("§e[Warning] No internal volume for water. Cooling will be impossible.");
            }
            if (steamCapacity <= 0) {
                player.sendMessage("§e[Warning] No space to store steam. Pressure will rise instantly.");
            }
            if (heatDissipation <= 0) {
                player.sendMessage("§e[Warning] No Heat Conductors found. Core temperature will rise uncontrollably.");
            }
            if (ventRate <= 0) {
                player.sendMessage("§e[Warning] No Vents detected. Steam pressure cannot be released.");
            }

            const reactorStats = {
                lavaCapacity,
                waterCapacity,
                steamCapacity,
                heatDissipation,
                ventRate,
                energyCap,
                bounds
            };

            entity.setDynamicProperty("reactorStats", JSON.stringify(reactorStats));
            entity.addTag('dorios:multi_liquids')
            entity.addTag('dorios:keep_liquids')
            entity.addTag('liquid0Type:lava')
            entity.addTag('liquid1Type:water')

            entity.runCommand('scoreboard players set @s liquidCap_0 1000000')
            entity.runCommand('scoreboard players set @s liquidCap_1 1000000')
            entity.runCommand('scoreboard players set @s maxLiquids 2')

            player.sendMessage("§a[Reactor] Thermo Reactor structure scanned successfully.");
            player.sendMessage(`§7[Reactor] Energy Capacity: §b${formatEnergyToText(energyCap)}`);
            player.sendMessage(`§7[Reactor] Lava Capacity: §b${formatLiquid(lavaCapacity)}`);
            player.sendMessage(`§7[Reactor] Water Capacity: §b${formatLiquid(waterCapacity)}`);
            // player.sendMessage(`§7[Reactor] Steam Capacity: §b${formatLiquid(steamCapacity)}`);
            player.sendMessage(`§7[Reactor] Heat Dissipation: §b${heatDissipation} K°/t`);
            player.sendMessage(`§7[Reactor] Steam Vented: §b${formatLiquid(ventRate)}/t`);
            player.sendMessage(`§7[Reactor] Max Pressure: §b${config.maxPressurePSI} PSI`);
            player.sendMessage(`§7[Reactor] Max Heat: §b${config.maxCoreTemperatureK} K°`);

        }
    })
})

/**
 * Updates the reactor info item in the generator inventory.
 *
 * @param {Object} reactorData Reactor state data.
 * @param {number} reactorData.rate     Reactor processing rate in mB/t.
 * @param {number} reactorData.temperature Current reactor temperature (K).
 * @param {number} reactorData.pressure Current reactor pressure (PSI).
 * @param {number} reactorData.time     Elapsed time in seconds.
 * @param {string} reactorData.warning  Warning message (empty if none).
 * @param {any} gen Generator entity wrapper with inventory component.
 */
function updateReactorInfoItem(reactorData, gen) {
    const item = gen.inv.getItem(2);
    if (!item) return; // nada que actualizar si no hay item

    item.nameTag = `
§r§3Producing: ${formatEnergyToText(reactorData.producing ?? 0)}/t
§r§3Burn Rate: ${reactorData.rate.toFixed(2)} mB/t
§r§3Temperature: ${reactorData.temperature.toFixed(2)} K
§r§3Efficiency: ${(reactorData.efficiency * 100).toFixed(2)}%%
§r${reactorData.warning}
  `;
    item.setLore(['']);
    gen.inv.setItem(9, item);

    const temperatureSegment = Math.floor(((reactorData.temperature ?? 300) - CORE_TMIN_K) / (CORE_TCAP_K - CORE_TMIN_K) * 31)
    let name = 'utilitycraft:temperature_'
    if (temperatureSegment < 10) name += '0'
    name += temperatureSegment
    const temperatureBar = new ItemStack(`${name}`)
    temperatureBar.nameTag = `§r§f${reactorData.temperature.toFixed(2)} K`
    gen.inv.setItem(10, temperatureBar);
    gen.entity.setDynamicProperty("reactorData", JSON.stringify(reactorData));
}

/**
 * Reactor state and statistics object.
 * 
 * @typedef {Object} ReactorInfo
 * @property {number} rate Reactor base processing rate (mB/t).
 * @property {number} pressure Current pressure of the reactor (PSI).
 * @property {number} temperature Current temperature of the reactor (K).
 * @property {number} efficiency Reactor efficiency percentage (0–100).
 * @property {number} time Elapsed time in seconds.
 * @property {string} warning Warning message if reactor is unstable, empty otherwise.
 * 
 * @property {number} lavaCapacity Maximum lava capacity (mB).
 * @property {number} waterCapacity Maximum water capacity (mB).
 * @property {number} steamCapacity Maximum steam capacity (mB).
 * @property {number} heatDissipation Heat dissipated per tick (K/t).
 * @property {number} ventRate Steam vented per tick (mB/t).
 * @property {number} energyCap Maximum internal energy capacity (DE).
 */

/**
 * Get full reactor info (data + stats) from entity.
 *
 * @param {any} entity Target entity with dynamic properties.
 * @returns {ReactorInfo}
 */
function getReactorInfo(entity) {
    try {
        const rawData = entity.getDynamicProperty('reactorData');
        const data = rawData ? JSON.parse(rawData) : config.initialReactorData;

        const rawStats = entity.getDynamicProperty('reactorStats')
        const stats = rawStats ? JSON.parse(rawStats) : {
            lavaCapacity: 0,
            waterCapacity: 0,
            steamCapacity: 0,
            heatDissipation: 0,
            ventRate: 0,
            energyCap: 0
        };

        return { ...data, ...stats };
    } catch {
        return { ...config.initialReactorData, lavaCapacity: 0, waterCapacity: 0, steamCapacity: 0, heatDissipation: 0, ventRate: 0, energyCap: 0 };
    }
}


/**
 * Show a modal to configure reactor burn rate and on/off state.
 * Reads current values from the entity (data.rate, data.state) and writes them back.
 * @param {Entity} entity - Reactor entity that holds the data.
 * @param {Player} player - Player to show the form to.
 */
async function showBurnRateConfigForm(entity, player) {
    // Read current reactor data
    const data = (typeof getReactorInfo === "function" ? getReactorInfo(entity) : {}) || {};
    const currentRate = Number(data.rate) || 0.1;
    const currentEnabled =
        typeof data.state === "string" ? data.state.toLowerCase() !== "off" : !!data.state;

    // Build form
    const form = new ModalFormData()
        .title("Reactor Burn Rate")
        .textField(
            `Burn rate (mB/t)\nFaster burn = more power & heat.\nSet a rate your cooling can sustain. e.g. 10`,
            `Set a burn rate: 100`,
            { defaultValue: `${currentRate}` }
        )
        .toggle("Enabled (on/off)", { defaultValue: currentEnabled });

    // Show and handle response
    const res = await form.show(player);
    if (res.canceled) return;

    const [rateInput, enabledToggle] = res.formValues;

    // Parse and validate
    let parsed = parseFloat(String(rateInput).replace(",", "."));
    if (!Number.isFinite(parsed) || parsed <= 0) {
        parsed = 0
    }

    // Write back
    data.rate = parsed;
    data.state = enabledToggle ? "on" : "off";

    if (typeof setReactorInfo === "function") {
        setReactorInfo(entity, data);
    } else if (typeof updateReactorInfo === "function") {
        updateReactorInfo(entity, data);
    } else if (entity.setDynamicProperty) {
        // Fallback if you store data as a dynamic property
        entity.setDynamicProperty("reactorData", JSON.stringify(data));
    }
}

/**
 * Spawns "campfire_tall_smoke_particle" on ~50% of vent blocks, chosen at random.
 * 8 -> 4, 7 -> 3, etc.
 * @param {import('@minecraft/server').Entity} entity
 * @param {number} [ratio=0.5] Fraction of vents to use (0..1)
 * @param {boolean} [center=true] If true, spawns at block centers (+0.5)
 */
function spawnRandomVentSmoke(entity, ratio = 0.25, center = true) {
    const dim = entity.dimension;

    let vents = [];
    const raw = entity.getDynamicProperty('ventBlocks');
    try { vents = raw ? JSON.parse(raw) : []; } catch { vents = []; }

    const n = vents.length;
    if (n < 2) return;

    const k = Math.max(1, Math.floor(n * ratio)); // 8->4
    // Partial Fisher–Yates to sample k unique vents without replacement
    for (let i = n - 1; i > n - 1 - k; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [vents[i], vents[j]] = [vents[j], vents[i]];
    }

    // Spawn particle on the sampled vents
    for (let i = n - k; i < n; i++) {
        const v = vents[i];
        const pos = center ? { x: v.x + 0.5, y: v.y + 0.5, z: v.z + 0.5 } : v;
        dim.spawnParticle("minecraft:campfire_tall_smoke_particle", pos);
    }
}

const PERIOD = 30; // 2 s

function fireLoop(e, f) {
    let t = (Number(e.getDynamicProperty('fs_t')) || 0) + f;
    if (t >= PERIOD) { e.dimension.playSound('block.campfire.crackle', e.location); t %= PERIOD; }
    e.setDynamicProperty('fs_t', t);
}

